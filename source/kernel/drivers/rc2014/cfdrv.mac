
CFBASE	EQU	010h		; IDE 0: IO BASE ADDRESS


;The addresses that the CF Card resides in I/O space.
;Change to suit hardware.
CFDATA		EQU	CFBASE + 00		; Data (R/W)
CFERR		EQU	CFBASE + 01		; Error register (R)
CFFEAT		EQU	CFBASE + 01		; Features (W)
CFSECCO		EQU	CFBASE + 02		; Sector count (R/W)
CFLBA0		EQU	CFBASE + 03		; LBA bits 0-7 (R/W, LBA mode)
CFLBA1		EQU	CFBASE + 04		; LBA bits 8-15 (R/W, LBA mode)
CFLBA2		EQU	CFBASE + 05		; LBA bits 16-23 (R/W, LBA mode)
CFLBA3		EQU	CFBASE + 06		; LBA bits 24-27 (R/W, LBA mode)
CFSTAT		EQU	CFBASE + 07		; Status (R)
CFCMD		EQU	CFBASE + 07		; Command (W)

FEATURE_8_BIT		EQU	1
ATA_CMD_SET_FEAT	EQU	0EFh

; RETURNS Z IF NOT PRESENT
; RETURNS NZ IF PRESENT

DRV_INIT_CF:
	CALL	CF_PROBE
	JR	Z, CF_FOUND

	LD	DE, CF_NOT_FOUND_MSG
	CALL	PRINT
	XOR	A
	RET

CF_FOUND:
	LD	DE, CF_FOUND_MSG
	CALL	PRINT

	CALL	CF_INIT
	OR	255
	RET


DEV_READ_CF:
	LD	A, .DATA
	LD	B, 0
	RET

DEV_WRT_CF:
	LD	A, .WRERR
	LD	B, 0
	RET


DEV_INFO_CF_FLDS:
	; SAVE SP IN XP
	PUSH	IX
	LD	IX, 0
	ADD	IX, SP

	; SAVE HL
	EX	DE, HL

	; RESERVE 512 BYTES FOR IDENTITY INFO
	LD	HL, -512
	ADD	HL, SP
	LD	SP, HL

	EX	AF, AF'
	CALL	CF_READ_IDENT

	; HL MODEL NUMBER (40 CHARS LONG)
	LD	HL, 036H
	ADD	HL, SP

	EX	AF, AF'
	EX	DE, HL		; RESTORE HL
	; DE REFERENCES MODEL NUMBER
	; HL IS RETURN BUFFER

	CP	1
	JR	Z, DEV_INFO_CF_MAN

	CP	2
	JR	Z, DEV_INFO_CF_NAME

	CP	3
	JR	Z, DEV_INFO_CF_SERIAL

	LD	A, 1

DEV_INFO_CF_END:
	; RESTORE SP
	LD	SP, IX
	POP	IX
	RET

DEV_INFO_CF_MAN:
	EX	DE, HL
	LD	BC, 40
	LDIR
	LD	B, 64-40
	CALL	RIGHT_PAD
	JR	DEV_INFO_CF_END

DEV_INFO_CF_NAME:
	EX	DE, HL
	LD	HL, CF_DRV_NAME
	LD	BC, CF_DRV_NAME_LEN
	LDIR
	LD	B, 64-CF_DRV_NAME_LEN
	CALL	RIGHT_PAD
	JR	DEV_INFO_CF_END

DEV_INFO_CF_SERIAL:
	LD	BC, 63
	ADD	HL, BC

	LD	(HL), '1'
	DEC	HL
	LD	(HL), '2'
	DEC	HL
	CALL	LEFT_PAD
	JR	DEV_INFO_CF_END


LUN_INFO_CF:
	LD	A, B
	CP	1
	JR	NZ, LUN_INFO_CF_INVALID

	LD	A, 0			; standard block device
	LD	(HL), 0
	INC	HL

	LD	(HL), 0			; sector size 512
	INC	HL
	LD	(HL), 2
	INC	HL

	LD	(HL), 0			; total sector count
	INC	HL
	LD	(HL), 0
	INC	HL
	LD	(HL), 0
	INC	HL
	LD	(HL), 0
	INC	HL

	LD	(HL), 1			; read only
	INC	HL

	LD	(HL), 0			; cyclinders
	INC	HL
	LD	(HL), 0
	INC	HL

	LD	(HL), 0			; heads
	INC	HL

	LD	(HL), 0			; sectors per track
	RET

LUN_INFO_CF_INVALID:
	LD	A, 1
	RET

CF_PROBE:
	LD	A, 1
	OUT	(CFSECCO), A
	LD	A, 2
	OUT	(CFLBA0), A
	LD	A, 4
	OUT	(CFLBA1), A

	IN	A, (CFSECCO)
	CP	1
	RET	NZ

	IN	A, (CFLBA0)
	CP	2
	RET	NZ

	IN	A, (CFLBA1)
	CP	4
	RET

CF_INIT:
	CALL	CF_WAIT_BUSY
	LD	A, FEATURE_8_BIT						; ENABLE 8 BIT MODE FEATURE
	OUT	(CFFEAT), A
	CALL	CF_WAIT_BUSY
	LD	A, ATA_CMD_SET_FEAT						; SEND FEATURE COMMAND
	OUT	(CFCMD), A
	; JR	CF_WAIT_BUSY

;***************************************************************************
; CF_WAIT_BUSY
; FUNCTION: LOOPS UNTIL STATUS REGISTER BIT 7 (BUSY) IS 0
;***************************************************************************

CF_WAIT_BUSY:
	IN		A, (CFSTAT)				; READ STATUS
	AND		080h					; MASK BUSY BIT
	JR		NZ, CF_WAIT_BUSY			; LOOP UNTIL BUSY(7) IS 0
	RET

;***************************************************************************
;CF_WAIT_CMD_RDY
;Function: Loops until status register bit 7 (busy) is 0 and drvrdy(6) is 1
;***************************************************************************
CF_WAIT_CMD_RDY:
	IN		A, (CFSTAT)					;Read status
	AND		0C0H						; %11000000 mask off busy and rdy bits
	XOR		040H						; %01000000 we want busy(7) to be 0 and drvrdy(6) to be 1
	JR		NZ, CF_WAIT_CMD_RDY
	RET

;***************************************************************************
;CF_WAIT_DAT_RDY
;Function: Loops until status register bit 7 (busy) is 0 and drq(3) is 1
;***************************************************************************
CF_WAIT_DAT_RDY:
	IN		A,(CFSTAT)					;Read status
	AND		088H						; %10001000 mask off busy and drq bits
	XOR		008H						; %00001000 we want busy(7) to be 0 and drq(3) to be 1
	JR		NZ, CF_WAIT_DAT_RDY
	RET

CF_READ_IDENT:
	CALL	CF_WAIT_CMD_RDY

	LD	A, 0E0H						; SELECT MASTER DRIVE
	OUT 	(CFLBA3),A					;

	LD	A, 0ECH						; identity command
	OUT	(CFCMD), A

	LD	B, 0
loop:
	djnz	loop
	; //TODO CHECK ERROR
	JR	CF_REDDAT


;***************************************************************************
;CF_RD_CMD
;Function: Gets a sector (512 bytes) into RAM buffer.
;***************************************************************************
CF_RD_CMD:
	CALL	CF_WAIT_CMD_RDY				;Make sure drive is ready for command
	LD	A, 020H					;Prepare read command
	OUT	(CFCMD), A				;Send read command
	CALL	CF_WAIT_DAT_RDY				;Wait until data is ready to be read

	IN	A, (CFSTAT)				;Read status
	AND	01H					;mask off error bit
	JR	NZ, CF_RD_CMD				;Try again if error

CF_REDDAT:						; READ sector into HL
	LD 	B, 0					;read 256 words (512 bytes per sector)
CF_RD_SECT:
	CALL	CF_WAIT_DAT_RDY
	IN 	A, (CFDATA)				;get byte of ide data
	LD 	(HL), A
	INC 	HL
	CALL	CF_WAIT_DAT_RDY
	IN 	A, (CFDATA)				;get byte of ide data
	LD 	(HL), A
	INC 	HL
	DJNZ 	CF_RD_SECT
	RET



CF_NOT_FOUND_MSG:	DB	"Compact Flash Module:", 9, "NOT PRESENT", 13, 10, 0
CF_FOUND_MSG:		DB	"Compact Flash Module:", 9, "PRESENT", 13, 10, 0

CF_DRV_NAME:		DB	"IDE/CompactFlash"
CF_DRV_NAME_LEN		EQU	$-CF_DRV_NAME
