
RS232_ID		EQU	8
GET_INFO_TABLE_FN	EQU	0

; RS232 SYSTEM VARIABLES
OLDINT		EQU	0FB0Ch	; INTERRUPT HOOK CALLED BY THE RS-232C (5 BYTES)
RSFCB		EQU	0FB04h	; FCB ("FILE CONTROL BLOCK") ADDRESS OF THE RS-232C
RSIQLN		EQU	0FB06h	; MAX NUMBER OF CHARACTERS THAT CAN BE STORED AT BUFFER RSFCB
MEXBIH		EQU	0FB07h  ; EXTENDED BIOS HOOK CALLED BY THE RS-232C
RS232WRK	EQU	MEXBIH	; REPORPOSE VARIABLE

; called at start of interrupt subroutine, before it has been checked if
; the interrupt was from VDP; used by e.g. RS232
H_KEYI			EQU	0FD9Ah

PSLTRG			EQU	0A8h		; I/O PORT ADDRESS OF PRIMARY SLOT REGISTER

WRSLT			EQU	00014h
GSLOT1			EQU	0402Dh
CALBNK			EQU	04042h
CHPUT			EQU	000A2H	; CHARACTER OUTPUT


	include	sio.inc

	EXTRN	SIO_INIT, SIO_PROBE

;;;;;;	; LD	(RSFCB), HL


	; ORG will be 07BD0h

	PUBLIC	RS232_JUMP_TABLE
RS232_JUMP_TABLE:
	DEFB	0		; MSX serial features (no TxReady INT, No Sync detect, No Timer INT, No CD, No RI)
	DEFB	1		; version number
	DEFB	0		; reserved for future expansion
	JP	INIT		; initialize RS232C port
	JP	OPEN		; open RS232C port
	JP	STAT		; ReaD STATus
	JP	GETCHR		; reveive data
	JP	SNDCHR		; send data
	JP	CLOSE		; close RS232C port
	JP	EOF		; tell EOF code received
	JP	LOC		; reports number of characters in the
				; receiver buffer
	JP	LOF		; reports number of free space left in the
				; receiver buffer
	JP	BACKUP		; back up a character
	JP	SNDBRK		; send break character
	JP	DTR		; turn on/off DTR line
	JP	SETCHN		; set channel number

INIT:				; initialize RS232C port
	CALL	SIO_INIT
	; Install fossil driver as well???

	; LD	A, 'R'
	; LD	(FOSSIL_MARK_1), A
	; LD	A, 'X'
	; LD	(FOSSIL_MARK_2), A


	; ; LD	HL, 21*3
	; ; CALL	ALLOC
	; LD	Hl, FOSSIL_JUMP_TABLE
	; LD	(FOSSIL_JUMP_TABLE_REF), HL
	; CALL	GETSL10
	; LD	(FOSSIL_JUMP_TABLE_SLOT), A

	LD	DE, MSG

BDOSFN	MACRO	fn
	LD	C, fn
	CALL	BDOS
	ENDM
STROUT		EQU	9	; DE = Address of $ terminated string
BDOS		EQU	5

	BDOSFN	STROUT

	XOR	A
	RET


MSG:	DB	"Are we inited yet.$", 0

OPEN:		; open RS232C port
	CALL	RS232_ENA_INTERRUPTS
	RET
STAT:		; Read Status
	RET
GETCHR:		; reveive data

	RET

;---------------------------------------------------------------------------------
;        Entry:  [A] = character to send
;        Return: carry flag is set if control break key was pressed
;                zero flag is set if time out error occured during waiting for
;                XON or/and CTS signal.
;        Modify: [F]
;
;        Description:
;         Send  specified character to RS232C port. The character flow control
;         by XON/XOFF  characters and/or  CTS (Clear  To Send)  line signal is
;         handled  if initialized  so. Time  out error  will be generated when
;         specified time passed during waiting for permision for transmission,
;         and the character will not be sent.
;
; DOES NOT SUPPORT FLOW CONTROL
; CURRENT ONLY SUPPORT CHANNEL B
SNDCHR:
	OUT	(DAT_CH), A		; send to port
	XOR	A			; SIGNAL SUCCESS
	RET

CLOSE:		; close RS232C port
	CALL	RS232_DIS_INTERRUPTS
	RET
EOF:		; tell EOF code received
	RET

LOC:
	LD	HL, 16 		; reports number of characters in the
	RET			; receiver buffer

LOF:		; reports number of free space left in the
;: receiver buffer
	RET
BACKUP:		; back up a character
	RET
SNDBRK:		; send break character
	RET
DTR:		; turn on/off DTR line
	RET
SETCHN:		; set channel number
	RET

;-----------------------------------------------------------------------------
;
; PRINT A ZERO-TERMINATED STRING ON SCREEN
; INPUT: DE = STRING ADDRESS
PRINT:
	LD	A, (DE)
	OR	A
	RET	Z
	CALL	CHPUT
	INC	DE
	JR	PRINT

; ENTRY POINT FROM MAIN RC2014 DRIVER FOR SIO DRIVER INITIALISATION
; PROBE SIO HARDWARE AND WRITE MSG TO CONSOLE
; INPUTS:
;	HL - WORK AREA - MUST BE AT LEAST SIOLEN LENGTH
	PUBLIC	DRV_INIT_SIO
DRV_INIT_SIO:
	LD	(RS232WRK), HL		; STORE INT_HANDLER ADDRESS

	; EX	DE, HL			; COPY INTERRUPT HANDLER INTO WORK ARA
	; LD	HL, SIO_INT
	; LD	BC, SIO_INT_LEN
	; LDIR

	LD	DE, MSG.SIO
	CALL	PRINT

	CALL	SIO_PROBE
	JR	Z, SIO_FOUND

	LD	DE, MSG.NOT
	CALL	PRINT

SIO_FOUND:
	LD	DE, MSG.PRESENT
	JP	PRINT

MSG.SIO:
	DB	"SIO/2 Module:        ", 9, 0

MSG.PRESENT:
	DB	"PRESENT", 13, 10, 0

MSG.NOT:
	DB	"NOT ", 0

RS232_ENA_INTERRUPTS:
	; EX	DE, HL
	; LD	HL, (RS232WRK)
	; ADD	HL, SIO_RCVBUF
	; LD	(HL), E
	; INC	HL
	; LD	(HL), D


	; DI

	; LD	DE, OLDINT		; GET ADDRESS OF OLD INT. HOOK SAVED AREA
	; LD	HL, H_KEYI		; GET ADDRESS OF INTERRUPT ENTRY HOOK
	; LD	BC, 5			; LENGHT OF HOOK IS 5 BYTES
	; LDIR				; TRANSFER

	; XOR	A
	; LD	IX, GSLOT1
	; CALL	CALBNK

	; LD	(H_KEYI+1), A		; SET SLOT ADDRESS
	; LD	A, $F7			; 'RST 30H' INTER-SLOT CALL OPERATION CODE
	; LD	(H_KEYI), A		; SET NEW HOOK OP-CODE
	; LD	HL, SIO_INT		; GET OUR INTERRUPT ENTRY POINT
	; LD	(H_KEYI+2), HL		; SET NEW INTERRUPT ENTRY POINT
	; LD	A, $C9			; 'RET' OPERATION CODE
	; LD	(H_KEYI+4), A		; SET OPERATION CODE OF 'RET'
	; EI

	RET

RS232_DIS_INTERRUPTS:
	RET


; ; ---------------------------------------
; ; COPIED TO WORK AREA IN PAGE 3
; ;
; SIO_INT:
; 	DI				; INTERRUPTS WILL BE RE-ENABLED BY MSX BIOS

; 	; CHECK TO SEE IF SOMETHING IS ACTUALLY THERE
; 	XOR	A			; READ REGISTER 0
; 	OUT	(CMD_CH), A
; 	IN	A, (CMD_CH)
; 	AND	01			; ISOLATE RECEIVE READY BIT
; 	RET	Z			; NOTHING AVAILABLE ON CURRENT CHANNEL

; SIO_INTRCV1:
; 	; RECEIVE CHARACTER INTO BUFFER
; 	IN	A, (DAT_CH)			; READ PORT

; 	LD	B, A			; SAVE BYTE READ
; 	LD	HL, 0			; SIO_RCVBUF
; SIO_RCVBUF	equ	($-2)-SIO_INT

; 	LD	A, (HL)			; GET COUNT
; 	CP	0			; COMPARE TO BUFFER SIZE
; SIO_BUFSZ	EQU	($-1)-SIO_INT

; 	JR	Z, SIO_INTRCV4		; BAIL OUT IF BUFFER FULL, RCV BYTE DISCARDED
; 	INC	A			; INCREMENT THE COUNT
; 	LD	(HL), A			; AND SAVE IT

; 	CP	0			; BUFFER GETTING FULL?
; SIO_BUF_HI	EQU	($-1))-SIO_INT

; 	JR	NZ, SIO_INTRCV2		; IF NOT, BYPASS CLEARING RTS

; 	LD	A, 5			; SELECTED REGISTER WRITE 5
; 	OUT	(CMD_CH), A
; 	LD	A, SIO_RTSOFF
; 	OUT	(CMD_CH), A

; 	XOR	A
; 	LD	(SIO_RTS), A

; SIO_INTRCV2:
; 	INC	HL			; HL NOW HAS ADR OF HEAD PTR
; 	PUSH	HL			; SAVE ADR OF HEAD PTR
; 	LD	A, (HL)			; DEREFERENCE HL
; 	INC	HL
; 	LD	H, (HL)
; 	LD	L, A			; HL IS NOW ACTUAL HEAD PTR
; 	LD	(HL), B			; SAVE CHARACTER RECEIVED IN BUFFER AT HEAD

; 	INC	HL			; BUMP HEAD POINTER
; 	POP	DE			; RECOVER ADR OF HEAD PTR
; 	LD	A, L			; GET LOW BYTE OF HEAD PTR
; 	SUB	SIO_BUFSZ+4			; SUBTRACT SIZE OF BUFFER AND POINTER
; 	CP	E			; IF EQUAL TO START, HEAD PTR IS PAST BUF END
; 	JR	NZ, SIO_INTRCV3		; IF NOT, BYPASS
; 	LD	H, D			; SET HL TO
; 	LD	L, E			; ... HEAD PTR ADR
; 	INC	HL			; BUMP PAST HEAD PTR
; 	INC	HL
; 	INC	HL
; 	INC	HL			; ... SO HL NOW HAS ADR OF ACTUAL BUFFER START
; SIO_INTRCV3:
; 	EX	DE, HL			; DE := HEAD PTR VAL, HL := ADR OF HEAD PTR
; 	LD	(HL), E			; SAVE UPDATED HEAD PTR
; 	INC	HL
; 	LD	(HL), D
; 	; CHECK FOR MORE PENDING...

; 	XOR	A
; 	OUT	(CMD_CH), A		; READ REGISTER 0
; 	IN	A, (CMD_CH)		;
; 	RRA				; READY BIT TO CF
; 	JR	C, SIO_INTRCV1		; IF SET, DO SOME MORE

; 	LD	A, (SIO_RTS)
; 	OR	A
; 	JR	Z, SIO_INTRCV4		; ABORT NOW IF RTS IS OFF

; 	; TEST FOR NEW BYTES FOR A SHORT PERIOD OF TIME
; 	LD	B, 40
; SIO_MORE:
; 	IN	A, (CMD_CH)		;
; 	RRA				; READY BIT TO CF
; 	JR	C, SIO_INTRCV1		; IF SET, DO SOME MORE
; 	DJNZ	SIO_MORE

; SIO_INTRCV4:
; 	; RESET INTERRUPT STATE IN SIO (CHANNEL A CONTROLS CHANNEL B ALSO)
; 	LD	A, 0
; 	OUT	(SIO0A_CMD), A
; 	LD	A, 038h
; 	OUT	(SIO0A_CMD), A
; 	RET

























; SIO_INT:
; 	DI				; INTERRUPTS WILL BE RE-ENABLED BY MSX BIOS

; 	; CHECK TO SEE IF SOMETHING IS ACTUALLY THERE
; 	XOR	A			; READ REGISTER 0
; 	OUT	(CMD_CH), A
; 	IN	A, (CMD_CH)
; 	AND	01h			; ISOLATE RECEIVE READY BIT
; 	RET	Z			; NOTHING AVAILABLE ON CURRENT CHANNEL

; SIO_INTRCV1:
; 	; RECEIVE CHARACTER INTO BUFFER
; 	IN	A, (DAT_CH)			; READ PORT

; 	LD	B, A			; SAVE BYTE READ
; 	LD	HL, (RSFCB)

; 	LD	A, (RSIQLN)		; BUFFER CHAR LEN
; 	CP	(HL)			; COMPARE TO BUFFER COUNT
; 	JR	Z, SIO_INTRCV4		; BAIL OUT IF BUFFER FULL, RCV BYTE DISCARDED
; 	INC	(HL)			; INCREMENT THE COUNT

; 	ADD	A, -16			; CALC A HIGH WATER MARK
; 	CP	(HL)			; BUFFER GETTING FULL?
; 	JR	NZ, SIO_INTRCV2		; IF NOT, BYPASS CLEARING RTS

; 	LD	A, 5			; SELECTED REGISTER WRITE 5
; 	OUT	(CMD_CH), A
; 	LD	A, SIO_RTSOFF
; 	OUT	(CMD_CH), A

; 	XOR	A
; 	LD	(SIO_RTS), A

; SIO_INTRCV2:
; 	INC	HL			; HL NOW HAS ADR OF HEAD PTR
; 	PUSH	HL			; SAVE ADR OF HEAD PTR
; 	LD	A, (HL)			; DEREFERENCE HL
; 	INC	HL
; 	LD	H, (HL)
; 	LD	L, A			; HL IS NOW ACTUAL HEAD PTR
; 	LD	(HL), B			; SAVE CHARACTER RECEIVED IN BUFFER AT HEAD

; 	INC	HL			; BUMP HEAD POINTER
; 	POP	DE			; RECOVER ADR OF HEAD PTR

; 	LD	A, (RSIQLN)		; BUFFER CHAR LEN
; 	ADD	A, 4
; 	LD	B, A
; 	LD	A, L			; GET LOW BYTE OF HEAD PTR
; 	SUB	B			; SUBTRACT SIZE OF BUFFER AND POINTER
; 	CP	E			; IF EQUAL TO START, HEAD PTR IS PAST BUF END
; 	JR	NZ, SIO_INTRCV3		; IF NOT, BYPASS
; 	LD	H, D			; SET HL TO
; 	LD	L, E			; ... HEAD PTR ADR
; 	INC	HL			; BUMP PAST HEAD PTR
; 	INC	HL
; 	INC	HL
; 	INC	HL			; ... SO HL NOW HAS ADR OF ACTUAL BUFFER START
; SIO_INTRCV3:
; 	EX	DE, HL			; DE := HEAD PTR VAL, HL := ADR OF HEAD PTR
; 	LD	(HL), E			; SAVE UPDATED HEAD PTR
; 	INC	HL
; 	LD	(HL), D
; 	; CHECK FOR MORE PENDING...

; 	XOR	A
; 	OUT	(CMD_CH), A		; READ REGISTER 0
; 	IN	A, (CMD_CH)		;
; 	RRA				; READY BIT TO CF
; 	JR	C, SIO_INTRCV1		; IF SET, DO SOME MORE

; 	LD	A, (SIO_RTS)
; 	OR	A
; 	JR	Z, SIO_INTRCV4		; ABORT NOW IF RTS IS OFF

; 	; TEST FOR NEW BYTES FOR A SHORT PERIOD OF TIME
; 	LD	B, 40
; SIO_MORE:
; 	IN	A, (CMD_CH)		;
; 	RRA				; READY BIT TO CF
; 	JR	C, SIO_INTRCV1		; IF SET, DO SOME MORE
; 	DJNZ	SIO_MORE

; SIO_INTRCV4:
; 	; RESET INTERRUPT STATE IN SIO (CHANNEL A CONTROLS CHANNEL B ALSO)
; 	LD	A, 0
; 	OUT	(SIO0A_CMD), A
; 	LD	A, 038h
; 	OUT	(SIO0A_CMD), A
; 	RET

; SIO_INT_LEN	EQU	$-SIO_INT

; 	PUBLIC	SIOLEN
; SIOLEN	EQU	SIO_INT_LEN

	END
