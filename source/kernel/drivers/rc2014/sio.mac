

	include	sio.inc

	PUBLIC	SIO_INIT
SIO_INIT:
	LD	BC, SIO_RTSOFF*256 + SIO0A_CMD
	CALL	SIOINIT
	LD	BC, SIO_RTSON*256 + SIO0B_CMD
	JP	SIOINIT

; -----------------------------------------------------------------------------
;
; INITIALISE SIO CHANNEL
; INPUTS:
;	B - RTS PORT STATE
;	C - SIO CHANNEL PORT
SIOINIT:
	LD	A, 0
	OUT	(C), A
	LD	A, 018H
	OUT	(C), A

	; WR4: CLK BAUD PARITY STOP BIT
	LD	A, 4
	OUT	(C), A
	LD	A, 0C4H
	OUT	(C), A

	; WR1: INTERRUPT OFF
	XOR	A

	; ; WR1: INTERRUPT ON
	; LD	A, 1
	OUT	(C), A
	LD	A, SIO_WR1VAL
	OUT	(C), A

	; WR2: IM2 VEC OFFSET
	LD	A, 2
	OUT	(C), A
	LD	A, 00H
	OUT	(C),A

	; WR3: 8 BIT RCV, CTS/DCD AUTO, RX ENABLE
	LD	A, 3
	OUT	(C), A
	LD	A, 0E1H
	OUT	(C), A

	; WR5: DTR, 8
	LD	A, 5
	OUT	(C), A
	OUT	(C), B
	RET

; SIO CHIP PROBE
; CHECK FOR PRESENCE OF SIO CHIPS AND POPULATE THE
; SIO_MAP BITMAP (ONE BIT PER CHIP).  THIS DETECTS
; CHIPS, NOT CHANNELS.  EACH CHIP HAS 2 CHANNELS.
; MAX OF TWO CHIPS CURRENTLY.  INT VEC VALUE IS TRASHED!
;
	PUBLIC	SIO_PROBE
SIO_PROBE:
	; INIT THE INT VEC REGISTER OF ALL POSSIBLE CHIPS
	; TO ZERO.
	XOR	A
	LD	B, 2			; WR2 REGISTER (INT VEC)
	LD	C, SIO0B_CMD		; FIRST CHIP
	CALL	SIO_WR			; WRITE ZERO TO CHIP REG

	; FIRST POSSIBLE CHIP
	LD	C, SIO0B_CMD		; FIRST CHIP CMD/STAT PORT
	CALL	SIO_PROBECHIP		; PROBE IT
	RET
;
SIO_PROBECHIP:
	; READ WR2 TO ENSURE IT IS ZERO (AVOID PHANTOM PORTS)
	CALL	SIO_RD			; GET VALUE
	AND	0F0h			; ONLY TOP NIBBLE
	RET	NZ			; ABORT IF NOT ZERO
	; WRITE INT VEC VALUE TO WR2
	LD	A, 0FFh			; TEST VALUE
	CALL	SIO_WR			; WRITE IT
	; READ WR2 TO CONFIRM VALUE WRITTEN
	CALL	SIO_RD			; REREAD VALUE
	AND	0F0h			; ONLY TOP NIBBLE
	CP	0F0h			; COMPARE
	RET

SIO_WR:
	OUT	(C), B			; SELECT CHIP REGISTER
	OUT	(C), A			; WRITE VALUE
	RET
;
SIO_RD:
	OUT	(C), B			; SELECT CHIP REGISTER
	IN	A, (C)			; GET VALUE
	RET

	END
